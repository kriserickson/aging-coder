{
  "questions": [
    {
      "name": "What are Kris's key technical skills?",
      "context": "Kris is a full-stack, production-first engineer and technical leader with 25+ years delivering and operating customer-facing systems across web, mobile, and large retail device fleets. His differentiator is breadth with real depth: he can design architecture, implement the hard parts end-to-end, and keep systems reliable and evolvable over years—especially under real constraints (retail hardware, multi-channel flows, legacy migrations, and revenue-critical uptime).\n\n**Languages (real production experience):** TypeScript, JavaScript, PHP, C#, Python, Java, Kotlin, Swift, VB, and C, with earlier production work in Perl and Ruby.\n\n**Frontend engineering (web UI at scale):** Kris is highly fluent in TypeScript/JavaScript and comfortable shipping complex SPAs and PWAs in Vue and React (also Angular). He handles the unglamorous but critical parts of frontends—state complexity, performance tuning, incremental migration, build tooling, and keeping UI codebases maintainable as they grow.\n\n**Runtimes & frameworks (pragmatic backend delivery):** Kris has built substantial backends and service layers across multiple ecosystems and can move between them based on the problem and team context:\n- **Node.js / TypeScript:** Express, Hapi, Hono, Next.js, Nuxt\n- **.NET / C#:** .NET Core, ASP.NET Core\n- **PHP:** Laravel, Symfony, Slim\n- **Python:** FastAPI\n\nHe’s comfortable designing and implementing REST and GraphQL APIs, integrating third-party partners, and building service boundaries that support multi-channel systems (web ↔ kiosk ↔ mobile) where correctness, reliability, and operability matter.\n\n**Distributed systems & operational engineering:** Kris has designed and supported systems with real-world distributed constraints—retries, idempotency, safe rollouts, telemetry, and failure handling. He’s comfortable with event-driven and messaging patterns (especially with solace) and with building the operational tooling required to keep systems stable in production.\n\n**Mobile & device platforms:** Kris has built and shipped on Android and iOS, including native work in Kotlin/Java and Swift, plus cross-platform development (Flutter, Cordova). He’s comfortable with service-style components and bridging to compiled/native libraries when needed—an important skill set when products extend beyond browsers into kiosks and other field-deployed devices.\n\n**Databases, caching, and data plumbing:** Kris works confidently across relational and NoSQL stores including MySQL, PostgreSQL, SQLite, MongoDB, Redis, and CouchDB. He understands the tradeoffs between transactional correctness, throughput, caching, and operational simplicity—particularly in systems where reporting, payments, and partner trust depend on reliable numbers.\n\n**DevOps, CI/CD, and operability:** Kris is hands-on with Docker and Kubernetes and has built/maintained CI/CD pipelines in GitHub Actions, GitLab CI, and Jenkins. He approaches DevOps as ‘make it operable’: repeatable deployments, safe releases, and strong observability so teams can diagnose issues quickly and avoid costly downtime.\n\n**Observability & production diagnostics:** Kris has worked with and shipped systems instrumented using Kibana, OpenSearch, OpenTelemetry, Sentry, New Relic, and Splunk. He uses observability to drive outcomes—debugging production issues, identifying customer friction/abandonment points, and improving system reliability—rather than treating monitoring as a box-check.\n\n**AI/ML & applied computer vision:** Kris has 10+ years of applied ML/CV experience in production photo workflows, primarily using OpenCV across Windows kiosk, Linux/.NET Core imaging services, and Android service implementations. He’s also hands-on with modern AI stacks (PyTorch, Hugging Face Transformers, Scikit-learn) and LLM workflow patterns, with a pragmatic bias toward approaches that actually outperform in production (e.g., leveraging strong low-cost foundation models when fine-tuning data/ROI isn’t there).\n\n**Cloud exposure (transparent scope):** Kris has worked within systems deployed on AWS/GCP/Azure and understands the operational concepts, but he’s transparent that he has not built greenfield infrastructure from scratch in those clouds and still has depth to build there. He learns quickly and is comfortable operating within existing cloud environments.\n\n**Modernization under constraints:** Kris has repeatedly modernized long-lived revenue systems—migrating stacks (including Windows-only components to Linux/.NET Core), introducing proven technologies at the right time, and keeping legacy and modern systems interoperable without breaking the business."
    } ,
    {
      "name": "Tell me about Kris's management experience",
      "context": "At Storefront—a small company that ultimately ran with a tight, high-impact development group—Kris led delivery by coordinating closely with the development team and project managers while partnering directly with key business stakeholders to decide what to build next and why, consistently prioritizing the work that delivered the most value. In his Director of Software Development role, he owned the practical “glue” work: aligning goals, translating business outcomes into clear technical plans, unblocking execution, and keeping the roadmap grounded in real constraints and customer impact. He also invested heavily in team growth, mentoring senior engineers while coaching newer developers across a wide range of backgrounds—from boot-camp grads with strong prior careers to PhD-level hires who were brilliant technically but new to shipping software in a business context—so the team could move faster without sacrificing quality or reliability."
    },
    {
      "name": "What major projects has Kris led?",
      "context": "Kris has led multiple long-running, revenue-critical product lines at Storefront, taking them from early concept through years (and decades) of real-world production operation across major retail partners. The work spans a white-label e-commerce platform, high-volume in-store kiosk systems, distributed remote management at massive device scale, and customer-facing file transfer and payment flows that materially changed adoption, revenue, and loss prevention.\n\n1) Storefront White-Label E-Commerce Platform (1999/2000–present)\n\nThe Storefront platform began in 1999 as a consulting engagement, but in early 2000 Kris helped drive the evolution into a configurable, white-label e-commerce product. A pivotal early milestone came when a platform customer asked Storefront to create an online photo ordering system for the Windows XP era. In 2001, online photo ordering was a rapidly expanding market with comparatively few established competitors, and that customer request became the catalyst for Storefront’s strategic shift toward photo commerce.\n\nKris led the transformation from “generic commerce” into “photo commerce”: building systems that supported photo-specific workflows (uploading, previewing, editing, product configuration), expanded product catalogs (prints evolving into photo products and print-on-demand), and the operational realities of photo fulfillment and retail integration. Critically, this wasn’t a one-off storefront—it became a repeatable platform used by 10+ major retailers and partners, including Rite Aid, Fred Meyer, King Soopers, Smith’s, Duane Reade, Benavides, Fuji Mexico, and CVS Mexico.\n\nThe platform also enabled cross-channel behavior that mattered commercially: a significant share of revenue came from mixed journeys—customers ordering online and printing/picking up via kiosk, or starting in-store and completing on the web. That kind of “web ↔ kiosk” continuity is hard to get right because it requires consistent product rules, order state, pricing/promotions, identity/session bridging, and predictable fulfillment handoffs. Kris led the engineering decisions and sequencing that kept the system evolvable while still stable enough to run for decades.\n\n2) Windows Photo Kiosk Platform (millions of prints, $1B+ sales influence)\n\nBuilding on the photo-commerce shift, Kris helped lead the creation of Storefront’s Windows Photo Kiosk product line—the in-store consumer experience that processed millions of prints and contributed to over $1B in sales across the business (with revenue split roughly 50/50 between kiosk and web, plus a large volume of orders that started on the web and were printed at the kiosk).\n\nThese kiosks weren’t “a screen on a PC.” They were full retail systems that had to be resilient, easy for non-technical store staff to support, and operationally predictable across thousands of locations. Kris led the product and technical direction that made the kiosk a real platform: the customer UI and ordering flow, the integration points to printing/lab systems and inventory constraints, and the end-to-end transaction path that retail partners could operationalize.\n\nStorefront also iterated on the kiosk concept into adjacent products as consumer behavior shifted—like a ringtone kiosk and a music kiosk (including CD burning and iPod upload workflows). That wasn’t novelty; it demonstrated Kris’s ability to reuse core platform capabilities (catalog, pricing, UI patterns, fulfillment/entitlements, operational telemetry) while adapting the product to the constraints and customer expectations of different eras.\n\n3) Remote Management & Monitoring Platform (30,000+ devices, 12,000+ requests/min)\n\nKris led the development and expansion of a remote management platform that started as “kiosk monitoring” and evolved into a distributed control plane for an entire fleet of retail devices and connected services. At scale, this platform supported 30,000+ devices and backend throughput on the order of 12,000 requests per minute, while also being robust enough to support multi-country deployments and varied retail environments.\n\nThe impact was both operational and financial:\n\nEliminated massive field-visit costs: Early in the Rite Aid rollout, the company responsible for in-store installs reportedly made 2x what Storefront made selling kiosk software—because every update and fix required expensive hands-on service visits. Kris’s remote update capability changed that equation: software could be rolled out and patched without spending six figures on in-store visits every time something needed to change.\n\nReduced downtime with actionable telemetry: The platform didn’t just say “a kiosk is down.” It enabled Storefront to detect and act on real retail failure modes—kiosks out of paper, stuck states, device health issues—so Storefront could notify store staff to fix problems quickly and restore sales.\n\nImproved funnel performance via real usage signals: Kris used the telemetry to identify where customers abandoned the flow (which pages or steps drove drop-off), enabling targeted UX and reliability improvements that directly impacted completion rate and revenue.\n\nMade sales/accounting trustworthy in messy retail realities: In some deployments, kiosk orders were paid at the counter. The remote system enabled accurate sales figures so shrinkage (loss/theft/mismatches) could be identified and addressed—critical for retail partner trust and for maintaining the program at scale.\n\nOver time, the remote management foundation expanded beyond Windows kiosks to cover lab/print systems, experiments like digital advertising, and later device generations including Android kiosks—showing that Kris didn’t build a one-generation tool, but a durable operational platform that could adapt as hardware and retail strategies changed.\n\n4) Kiosk File Transfer + Payment System (Node.js/React) — adoption + shrinkage wins\n\nKris led the creation of a modern file transfer system designed to remove a major point of friction: customers previously had to plug phones into kiosks or bring flash drives/memory cards. The new flow let customers scan a barcode and upload photos to the kiosk without physical connection—cleaner, faster, and far more aligned with how people actually carried photos as smartphones took over.\n\nThe outcome was immediate and measurable: kiosk usage increased ~50% once customers no longer had to plug their phones in.\n\nThe project then expanded from “transfer” into “payments” using the same core infrastructure: session identification + secure handoff. Kris recognized that if you can securely connect a user’s phone session to a kiosk session, you can also use that to handle payment in a way that reduces both friction and risk. That meant:\n\nreducing the need for customers to type credit card details on a public kiosk, and\n\navoiding expensive payment hardware devices in the kiosk itself.\n\nWhen payment was introduced through this infrastructure, sales increased and shrinkage disappeared—a rare combination that retail partners love because it improves both top-line revenue and loss prevention at the same time.\n\n5) Distributed SaaS platform for customizable products (shared services across channels)\n\nAlongside the core kiosk + web business, Kris also led/owned substantial parts of a distributed SaaS platform that supported customizable products and shared capabilities across channels (web, kiosk, mobile). The through-line here is not just “built services,” but building operable services—systems designed to be monitored, debugged, rolled out safely, and incrementally modernized while keeping revenue systems running.\n\nLeadership and team impact (how he led these efforts)\n\nAcross these projects, Kris led engineering in a way that matched Storefront’s reality: a small company where priorities must be chosen carefully and every developer needs leverage. At peak, he coordinated a team of ~15 developers, averaged around 10, and delivered major outcomes even in the final year with a team of ~6. He coordinated between engineering and project managers, worked directly with key business partners to prioritize the roadmap for maximum stakeholder value, and kept delivery grounded in what would move revenue, reliability, and partner trust.\n\nHe also built strong teams by mentoring across a wide range of backgrounds—supporting senior developers while helping newer engineers ramp quickly, from boot-camp graduates with prior careers to PhD hires who were technically strong but new to business software delivery. That mentorship mattered because Storefront’s products weren’t toy apps—they were mission-critical systems running in retail, where reliability, operational clarity, and trust with partners determine whether the program grows or gets shut down."
    },
    {
      "name": "How has Kris worked with AI/ML technologies?",
      "context": "Kris has applied AI/ML in real production photo systems for more than a decade—well before the current LLM boom—primarily through computer vision for consumer photo workflows. At Storefront, he built and evolved imaging capabilities used across the Windows Photo Kiosk and online photo ordering platform, including automated photo enhancements (color correction pipelines), classic consumer-photo fixes (red-eye reduction), and practical image analysis features built largely on OpenCV.\n\nThat work spanned multiple platform generations:\n- Windows kiosk era: OpenCV-based imaging ran directly on Windows kiosks, and the Storefront Imaging API was initially Windows-only.\n- Modernization era (2019+): the imaging stack was moved to Linux and .NET Core (early .NET Core 1.1 timeframe), preserving core photo workflows while modernizing deployment and operations.\n- Android kiosk era: imaging capabilities were also delivered on Android as a Java service that leveraged cross-compiled OpenCV C components—adapting the same CV foundation to mobile/embedded constraints.\n\nKris’s computer-vision work focused on features that made large consumer photo libraries usable and improved downstream product generation quality. A key example was similar-image stacking: Kris implemented near-duplicate grouping so users saw clean stacks instead of long runs of essentially identical photos. The implementation combined perceptual hashing (pHash), color-histogram similarity, and capture date/time signals to robustly cluster real-world images despite minor edits, lighting shifts, or burst-mode sequences. He also implemented face detection and intelligent auto-cropping for templated products—especially auto-photobook generation—with support for multiple faces, safe margins, and aspect-ratio constraints so crops looked intentional rather than random. Kris additionally explored early OpenCV-style classification signals (e.g., coarse scene/object indicators like grass/animals) as groundwork for richer organization/search experiences, though Storefront never shipped a full search product on top of those labels.\n\nIn his final year at Storefront, Kris expanded into modern generative AI and LLM-driven product work with a pragmatic, production-minded approach:\n- Image-processing automation: he prototyped Python-based pipelines initially using PyTorch, later switching portions to Pillow when deterministic image processing was the better fit than model-driven approaches.\n- Image generation integrations: he integrated multiple image-generation APIs (including DALL·E, Stability.ai, and Flux) to explore a key customer promise—helping users produce a sellable product image without requiring Photoshop-level skills. In practice, this also enabled demo-ready experiences without requiring customers to supply source imagery; analytics showed negligible direct sales impact, but it validated UX flows and reduced demo friction.\n- LLM product-description generation: he built an early-stage system to generate improved product descriptions for Storefront’s customizable-products SaaS platform. It combined existing product descriptions with user-supplied creation metadata (title and other inputs) and LLM-derived classification of the user’s created image to produce more complete, consistent copy.\n\nTo operate these AI features responsibly and cost-effectively—especially the more expensive image generation—Kris implemented an ‘AI proxy’ layer that enforced practical safeguards. The proxy focused on abuse prevention, cost control, and safe operation (e.g., gating and filtering requests, limiting expensive calls, and ensuring the system could be monitored and throttled), rather than relying on a fully developed brand-voice or editorial workflow, since the description generator was still early-stage.\n\nKris has also experimented with model adaptation and fine-tuning techniques (e.g., LoRA and related lightweight approaches) using PyTorch and Hugging Face Transformers. However, he deliberately did not ship fine-tuned models to production: the available domain data was insufficient to outperform strong, low-cost foundation models, and in evaluations—particularly around the product-description generator—small/cheap hosted foundation models consistently outperformed locally-run or fine-tuned attempts.\n\nSeparately, Kris has used AI-assisted coding tools since 2021 (e.g., GitHub Copilot and newer agentic/IDE workflows like Cursor/Windsurf-style environments) as a force multiplier for prototyping and refactoring, while maintaining senior-engineering rigor around correctness, maintainability, and operational ownership."
    },
    {
      "name": "Can you expand on Kris's enterprise SaaS experience?",
      "context": "Kris has 25+ years building, operating, and modernizing enterprise SaaS platforms where “enterprise” means real partner integrations, strict reliability expectations, and systems that must evolve without breaking revenue. At Storefront, he helped turn an early consulting engagement (1999) into a configurable white-label platform used by major retailers and partners, including Rite Aid, Fred Meyer, King Soopers, Duane Reade, Smith’s, Benavides, Fuji Mexico, and CVS Mexico. The platform supported high-volume photo commerce across both web and in-store kiosks, with customer journeys that often crossed channels (order online, print/pick up in-store), requiring consistent catalog rules, pricing/promotions, identity/session handling, order state, and fulfillment handoffs.\n\nKris’s enterprise SaaS experience is grounded in scale and operability across a broad international footprint. The Storefront ecosystem ran in Canada, the U.S., Mexico, Sweden, Germany, Norway, the U.K., France, Denmark, the Netherlands, and Belgium—each with its own retail constraints and operational realities. He also led a remote management and monitoring platform that started as kiosk monitoring and grew into a distributed control plane for a large device fleet (30,000+ devices; ~12,000 requests/minute). That platform reduced downtime and operating cost by enabling remote updates and configuration changes that would otherwise require expensive in-store service visits, provided actionable telemetry (device down, out-of-paper, health signals), and surfaced funnel behavior to identify where customers abandoned the flow so teams could fix the highest-impact friction points.\n\nOn the commercial side, Kris built enterprise capabilities that improved partner trust and profitability. He implemented reporting and transaction visibility that made sales figures reliable even in environments where kiosk orders were sometimes paid at the counter—enabling shrinkage to be detected and addressed. He also led work on a kiosk file-transfer and payment system that removed customer friction (no need to plug phones into kiosks), driving ~50% higher kiosk usage; when payment was handled through that secure session infrastructure, sales increased and shrinkage disappeared.\n\nMore recently, Kris co-architected and delivered a distributed SaaS platform focused on selling photo finishing products through Shopify (with an eye toward expanding to other commerce platforms over time). This included building the integration surface area required for enterprise e-commerce—product catalog sync, pricing rules, order ingestion and lifecycle, fulfillment/lab integration, and partner operational support—while also integrating Storefront’s photo editing/customization experience directly into third-party e-commerce sites so customers could personalize photo products on the partner’s platform without being bounced through a separate system. Across all of these efforts, Kris consistently balances modernization with continuity: incremental upgrades, safe releases, and operational tooling that keeps long-lived revenue systems stable while still moving forward."
    },
    {
      "name": "What measurable outcomes came from those projects?",
      "context": "Measurable outcomes from Kris’s major projects show up in longevity, scale, revenue impact, adoption lift, and hard operational savings:\n\n25+ years of continuous production operation (platform durability): Kris helped architect and modernize a white-label e-commerce + photo commerce platform that has remained operational for over 25 years, supporting 10+ major retail partners and multiple product generations without a “stop-the-world rewrite.” The measurable outcome here is longevity under real load, plus sustained partner usage across shifting consumer and retail environments.\n\nHigh-volume photo commerce with enterprise retail reach: Across web + kiosk channels, the platform processed millions of prints per year and supported a meaningful share of large retail photo finishing programs. In particular, Rite Aid’s photo finishing peaked around ~$1B/year in sales, and Storefront’s ecosystem captured value across both web ordering and in-store kiosk printing/pickup flows—meaning revenue wasn’t isolated to one channel but enabled the combined journey.\n\nRemote Management Platform at fleet scale: Kris led the evolution of remote management from simple kiosk monitoring into a distributed control plane supporting 30,000+ devices with sustained throughput around 12,000 requests/minute. The measurable outcomes weren’t just scale, but operational leverage: remote updates/configuration reduced dependence on expensive in-store servicing and enabled proactive issue response (down devices, out-of-paper, etc.), keeping revenue systems available and reducing downtime.\n\nField-service cost avoidance (real dollars saved): Early on, the kiosk install/servicing vendor in Rite Aid reportedly earned ~2× what Storefront earned from kiosk software—because ongoing updates and fixes required in-store visits. Kris’s remote update/management capability directly reduced that burden. He’s described avoiding six-figure service costs that would otherwise recur when updates required physical visits (the concrete outcome: updates and maintenance shifted from truck-roll economics to software economics).\n\nFile transfer modernization drove adoption: Moving customers from “plug your phone into the kiosk / bring a USB stick” to barcode-based file transfer increased kiosk usage by ~50%. That’s a clear, measurable funnel improvement attributable to reducing friction at the exact point where customers used to stall.\n\nPayments modernization improved revenue integrity: Using the same secure session infrastructure to handle payment reduced friction and eliminated key retail loss modes: after payment was instituted through this flow, sales increased and shrinkage disappeared (especially in counter-payment environments). That’s a rare “up + down” metric pair: higher sales plus lower loss.\n\nHardware cost avoidance at kiosk scale: By shifting payment away from requiring specialized kiosk payment hardware, the solution avoided credit-card hardware costs across thousands of kiosks, while also improving the customer experience (less card entry on public kiosks) and lowering operational complexity."
    },
    {
      "name": "How has Kris used AI/ML and modern tools to improve delivery?",
      "context": "Kris has used AI/ML and modern developer tooling as leverage to improve delivery: faster iteration without lowering the bar on correctness, maintainability, or operability. Since 2021 he’s championed AI-assisted coding (GitHub Copilot plus modern agentic/IDE workflows like Cursor and Windsurf-style environments) to accelerate routine implementation, refactoring, test scaffolding, and the repetitive “glue” work that usually slows teams down—while keeping changes small, reviewable, and production-safe. He treats these tools as amplifiers rather than autopilot: generated code still gets the same senior-engineering scrutiny (edge cases, error handling, readability, architectural fit, and operational considerations). He also applies AI beyond coding assistance with hands-on experience in PyTorch and Hugging Face Transformers, prompt engineering, and practical evaluation of fine-tuning approaches like LoRA-style adaptation experiments (including SIT-style experimentation), but stays pragmatic—preferring strong low-cost foundation models when data, ROI, latency, or operational complexity don’t justify fine-tuning. Related writing on his blog includes: Leveraging LLMs for Coding: Insights and Real-World Experiences https://agingcoder.com/posts/leveraging-llms-for-coding-insights-and-real-world-experiences/\n ; The Trough of Disillusionment https://agingcoder.com/posts/the-trough-of-disillusionment/\n ; LLMs and Coding 6 months later https://agingcoder.com/posts/llms-and-coding-6-months-later/\n ; Book Review: Vibe Coding https://agingcoder.com/posts/book-review-vibe-coding/ On the product and platform side, Kris also has hands-on AI/ML experience that goes beyond coding assistance. He has worked with PyTorch and Hugging Face Transformers, and he has experimented with model adaptation and fine-tuning techniques such as LoRA and related lightweight approaches (including SIT-style experimentation), alongside prompt engineering and structured-output techniques. In practice, he evaluates these techniques the way a product-minded engineer should: by measuring whether they outperform strong foundation models given available domain data, latency, cost, and operational complexity. For example, in experiments around LLM-driven content generation workflows, he found that small, inexpensive hosted foundation models often beat local or fine-tuned approaches when the training data wasn’t sufficient—so he optimized for outcomes and maintainability rather than insisting on fine-tuning for its own sake.\n\nFinally, Kris has applied “modern tools” broadly—not just AI—to improve delivery: adopting better observability and diagnostics (OpenTelemetry-style instrumentation and error tracking), tightening CI/CD loops, and using automation to make systems easier to ship and operate. The consistent theme is leverage: use the newest tools where they create real advantage, keep the bar for correctness high, and build workflows that make teams faster without sacrificing reliability."
    },
    {
      "name": "Can you describe Kris's approach to modernizing legacy systems?",
      "context": "Kris approaches legacy modernization as an engineering discipline: preserve what works, reduce risk with tests and observability, and evolve systems incrementally so the business keeps running. Two long-standing influences on his approach are Martin Fowler’s “Refactoring” and Michael Feathers’ “Working Effectively with Legacy Code,” especially the idea that you can’t modernize confidently without a safety net. Kris is deliberate about building that safety net—adding regression coverage (often starting with characterization tests), tightening feedback loops via CI, and instrumenting systems so changes can be validated in production without guesswork. The goal is to create the feeling of security required to make meaningful upgrades without breaking everything.\n\nA good example is the original Windows kiosk: Storefront shipped the first generation in VB6 because it was the practical choice at the time (VB.NET/C# weren’t yet publicly available). Rather than rewriting it from scratch later, Kris led a multi-year evolution where new functionality moved into C# components behind stable boundaries, called from the VB6 shell. Over roughly five years, more and more of the kiosk’s real behavior lived in modern, testable C# modules, until VB6 was largely just a thin host while the kiosk’s core logic, integrations, and capabilities ran in C#. That pattern—create seams, move functionality behind interfaces, replace pieces safely—became a repeatable modernization strategy.\n\nKris is strongly biased against “throw it away and start over” rewrites, in line with the classic warning from Joel Spolsky about how rewrites tend to fail in practice. His preference is to modernize by putting proxies/facades around legacy systems (monoliths, old services, old runtimes), then gradually replacing capabilities behind those stable interfaces. That can mean introducing a gateway API over a monolith, extracting a service one workflow at a time, or incrementally migrating a subsystem to a new language/framework while preserving the existing contract. In practice, this approach is how he’s modernized Storefront’s platforms over time: integrating web and mobile experiences with legacy backends, improving maintainability and performance without interrupting revenue, reducing operational costs through safer deployments and fewer brittle dependencies, and building new systems (like kiosk file transfer and payments) that work across both legacy Windows kiosks and modern Android kiosks.\n\nLink referenced: https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/"
    },
    {
      "name": "What were the key responsibilities as Director?",
      "context": "As Director of Software Development (2020–2025), Kris owned company-wide architecture and delivery standards across Storefront’s web, mobile, and retail-device ecosystem, with day-to-day accountability for code quality, technical direction, and shipping outcomes. His responsibilities covered architecture standards and tech stack decisions, prioritizing developer time for maximum business value, and owning incident response when issues were rooted in software (while partnering with infrastructure-focused teammates when problems were primarily server/ops). In practice he was on the hook for uptime and on-call outcomes for code-related production issues, and he consistently drove improvements that made releases safer and faster—moving from slower release cycles earlier on to weekly releases once CI/CD became reliable.\n\nKris’s scope was broad and concrete: he was fully responsible for the Remote Management platform, consumer-facing mobile applications, the web front-end, internal store utilities, and the “personalizer” embedded into external partner sites (notably Kirkland’s). He shared ownership for major legacy and platform pillars including the Windows Kiosk, Android Kiosk, and the Shopify-based SaaS integration—often spearheading initial development and delivery, then handing mature products to other managers once stable and operational. He led through major shifts in team size and company context: at peak, the org included ~15 developers, 4 QA, 4 PMs, and 3 designers; by the final year, it was ~6 developers, 2 QA, 2 PMs, and 1 designer. He was directly involved in hiring, established pairing and code review culture, introduced practices like lunch-and-learns, and worked intentionally to keep team cohesion high after the COVID transition from office-first to mostly remote.\n\nOn product delivery, Kris drove both modernization and new revenue. He led key legacy modernization efforts such as migrating Windows-only imaging services to Linux/.NET Core, and tackled “keep revenue running while changing engines” challenges—most notably evolving the SaaS offering toward a microservices architecture that initially called into the monolith via APIs, then progressively replaced monolith dependencies by integrating directly with the monolith’s database and services in a controlled, phased way. He oversaw and guided shared libraries and platform tooling across C#, TypeScript, and lower-level C components—especially imaging libraries—and owned important integration infrastructure, including monolith integration patterns using the Solace message bus and developer tooling that enabled front-end teams to interact with Solace from the browser.\n\nKris also delivered high-impact partner solutions under tight timelines. A standout example was unblocking an entirely new revenue stream by creating the Kirkland’s personalizer: an embeddable iframe experience that enabled customers to personalize Design Direct print-on-demand products directly on Kirkland’s site, while integrating with partner fulfillment via EDI. He built the initial proof-of-concept over a weekend, demonstrated it to Kirkland’s web team the following week, and drove the project to completion in under three months—turning a partnership opportunity into a shippable, revenue-generating system. On mobile, he owned the strategy shift from white-labeled iOS/Android PhotoSite apps toward a mobile-first PWA, and he led targeted mobile delivery where it mattered—such as the TelCel app for Mexico (Android-first), which supported photo upload, cropping, and payment via TelCel’s SOAP API against user pay-per-use credits, designed intentionally as a simple, low-friction consumer experience."
    },
    {
      "name": "What team size and scope did that role cover?",
      "context": "As Director, Kris’s team scope flexed with the company’s size and business cycle. At peak, he operated within an org of roughly 15 developers, 4 QA, 4 PMs, and 3 designers; in the final year, that condensed to about 6 developers, 2 QA, 2 PMs, and 1 designer. While the broader engineering org could be larger, his direct management/mentorship span was typically up to ~10 developers, with responsibility for hiring, onboarding, pairing and code review culture, and keeping delivery effective as the company shifted from in-office to mostly remote after COVID. He also mentored across a wide spectrum of experience levels—from boot-camp grads with prior careers to highly academic hires (including PhDs) who needed help translating strong technical ability into shipping software in a business environment.\n\nScope-wise, Kris’s remit was genuinely company-wide across web, mobile, and kiosk platforms, but with clear ownership boundaries. He was fully responsible for the Remote Management platform, web front-end, consumer-facing mobile work, store utilities/internal tools, and the embedded “personalizer” used by external partners (notably the Kirkland’s integration). He had shared responsibility for the Windows Kiosk, Android Kiosk, and Shopify SaaS integration work—often spearheading initial builds and early delivery, then transitioning mature product lines to other leaders once stable. Across all of this, his scope included both feature delivery and the platform foundations that made delivery sustainable: core/shared libraries (imaging in C#/TypeScript plus lower-level components), legacy modernization strategy, integration patterns around the monolith (including Solace message bus usage), front-end developer tooling for those integrations, and the CI/CD and release practices that eventually enabled weekly releases when the pipeline became reliable."
    },
    {
      "name": "What consumer-facing mobile apps were delivered?",
      "context": "Kris delivered and led multiple consumer-facing mobile efforts at Storefront and as a consultant, spanning native and cross-platform approaches depending on the business need and timeline. Earlier, Storefront shipped a white-label iOS/Android “PhotoSite” mobile app that covered the core end-to-end photo commerce flow—account/login, photo upload, editing/cropping, ordering, payment, and pickup/fulfillment integration—before the company later consolidated that experience into a mobile-first progressive web app. In his final years, Kris directly created and delivered a TelCel-focused Android app for Mexico (an intentionally Android-first market), designed as a simple, low-friction consumer experience: photo upload, cropping, and payment via TelCel’s SOAP API against the user’s pay-per-use credits.\n\nIn addition to Storefront’s first-party apps, Kris has built and shipped a broad range of mobile applications as a consultant, using Cordova and Flutter as well as modern native stacks and UI frameworks like Jetpack Compose (Android) and SwiftUI (iOS). He’s also worked in React Native where it fit project constraints. That breadth matters because he’s comfortable making the tradeoffs between native quality, development speed, platform access, and long-term maintainability rather than forcing one tool everywhere.\n\nFinally, Kris’s mobile experience isn’t limited to “app screens.” The Android Kiosk program required systems-level Android work: building and supporting a constrained, locked-down device environment with custom OS-level behavior. Storefront created a custom ROM, multiple native services, and even a ROM updater. Kris oversaw that work at the architectural and delivery level—ensuring the platform was operable and maintainable at fleet scale—while other engineers owned portions of the implementation."
    },
    {
      "name": "How were legacy systems modernized during this time?",
      "context": "During Kris’s Director tenure, legacy modernization was treated as a continuous program rather than a one-time rewrite: keep revenue systems running, create safety (tests/CI/observability), and replace components incrementally behind stable interfaces. In practice, that meant modernizing the highest-risk or highest-leverage areas first, while preserving compatibility with long-lived retail deployments and partner integrations.\n\nA core example was the evolution of kiosk and imaging infrastructure. Storefront’s early Windows kiosk stack began in VB6 for pragmatic reasons, but over time Kris drove a careful transition where new functionality moved into C# components called from the VB6 shell—eventually leaving VB6 as a thin host with the real system behavior living in modern, testable modules. That same modernization mindset carried forward into later platform shifts, including migrating Windows-only imaging services to Linux and .NET Core to improve deployability, maintainability, and long-term support.\n\nModernization also meant bridging old and new product generations rather than forcing clean breaks. Kris designed the Kiosk File Transfer and Payment system (Node.js + React) specifically so it could be adopted by both legacy Windows kiosks and modern Android kiosks, enabling a unified customer flow across a mixed fleet. This removed major friction (no phone plug-in), increased kiosk usage significantly, and improved revenue integrity once payment was introduced—without requiring a full replacement of the kiosk stack.\n\nOn the enterprise SaaS side, Kris led the “change engines without stalling the car” approach to moving from a monolith toward a more distributed architecture. The Shopify-oriented SaaS platform started by calling into the monolith through APIs (proxies/facades), then progressively phased those dependencies out by owning more direct integrations and capabilities while still interoperating with the existing database and workflows. Throughout, he emphasized incremental delivery, safe rollouts, and operational tooling—so modernization improved stability and performance rather than creating a risky multi-year rewrite."
    },
    {
      "name": "What is the system prompt used by the chat?",
      "context": "The chat uses the following system prompt: 'You are a professional job fit analyst. Your task is to provide an honest, balanced assessment of how well Kris Erickson's experience and skills match a given job description.\n\nOperating principles:\n- Be objective and honest. Do not oversell or undersell.\n- Base your assessment ONLY on the candidate's actual experience provided in the context.\n- Identify genuine matches where skills and experience align with requirements.\n- Identify genuine gaps where requirements are not met by the candidate's background.\n- Do not fabricate or exaggerate qualifications.\n\nOutput format:\nYou MUST respond with valid JSON matching this exact structure:\n{\n  \"verdict\": \"strong\" | \"moderate\" | \"weak\",\n  \"jobTitle\": \"extracted or inferred job title from the posting\",\n  \"summary\": \"2-3 sentence overall assessment\",\n  \"matches\": [\n    { \"title\": \"Short match title\", \"description\": \"Why this is a match with specific evidence\" }\n  ],\n  \"gaps\": [\n    { \"title\": \"Short gap title\", \"description\": \"What's missing and how significant it is\" }\n  ],\n  \"recommendation\": \"1-2 sentence recommendation for the hiring manager\"\n}\n\nVerdict guidelines:\n- \"strong\": 70%+ of key requirements are met with direct, relevant experience\n- \"moderate\": 40-70% of requirements met, or close matches exist\n- \"weak\": Less than 40% of key requirements met\n\nInclude 3-6 matches and 2-4 gaps. Be specific with evidence from the resume.'",
      "verbatim": true
    },
    {
      "name": "How does the RAG (retrieval) system work?",
      "context": "Simple overview\n\nRAG (retrieval‑augmented generation) means: before asking the LLM to answer, retrieve relevant pieces of your knowledge base and include them with the prompt so the model answers grounded in actual source content. This RAG system uses Cloudflare Workers AI with the BGE-small embedding model to find relevant context, CV data is always included as base context (without embedding search). Additional context can be added and are embedded for semantic search from the questions.json file found at https://github.com/kriserickson/aging-coder/blob/main/api-worker/src/rag-data/questions.json . When a question is asked, the system finds the most relevant context chunks and includes them with the question sent to the LLM. In this system: How it works (step by step)\n\nIngest & chunk\nQuestions are turned into embeddings (while in a real system these would be documents that would be chunked and placed into a vecotr database, we are simplifying things here by keeping the coontext relatively short and not bothering with chunking).\nEmbed\nEach question context is converted into a numeric embedding using Cloudflare Workers AI’s BGE-small embedding model. These fixed-length vectors capture semantic meaning.\nStore index\nEmbeddings are stored in an index in a ValKey (a Redis clone) database for later lookup (we try to keep them in  in-memory but Cloudflare shuts down works often).\nQuery-time flow\nThe incoming question is embedded with BGE-small.\nThe system computes similarity between the question embedding and each document chunk embedding (cosine similarity).\nIt selects the top‑k scoring chunks (and applies any score threshold or exact-match rules).\nThe selected chunks + the always-included CV base context are assembled into the prompt sent to the LLM. This keeps answers grounded in real source content.\nSafety & pragmatics\nThe prompt assembly respects token limits (truncate/merge as needed), respects provenance (cite or attach metadata), and falls back to defaults if no high-confidence chunks are found."
    },
    {
      "name": "Where did you get the idea for this?",
      "context": "I got the idea of this interactive CV by writing my blog, I frequently create documents, research and pages of writing (and sometimes code) that is never included in the blog post.  Last spring I was thinking about augmenting my blog with a chat interface that could answer questions about my experience and skills, and I realized that a RAG (retrieval-augmented generation) approach would be a great fit.  After loosing my job and sending dozens of resumes into the AI ATS (Applicant Tracking System) machine, I thought I could try to get AI to work with me rather than be the adversary that I was trying to beat to get my resume noticed.  While I had been planning this for a while, Nate Jones YouTube video 'Linked in is Dead'  https://www.youtube.com/watch?v=0teZqotpqT8 inspired me to get this done, as well as gaving me the idea for the Fit Assesment."
    },
    {
      "name": "Where can I find the source code?",
      "context": "The source code for this interactive CV is open source at https://github.com/kriserickson/aging-coder . The blog uses Eleventy (11ty) for static site generation, but you can find the front-end code the `cv` directory and the API code in the `api-worker` directory,  It is using Cloudflare Workers + Hono for the API, and routes LLM model calls through OpenRouter (including OpenAI models). Feel free to fork it or adapt it for your own interactive CV or other RAG apps. Much of the implementation was produced with LLM help but the source code may inspire or provide you a good starting point, but the real work is the content: gathering accurate data about yourself, organizing it into retrievable chunks/Q&A, and iterating on what the system can reliably answer.",
      "verbatim": true
    },
    {
      "name": "Which frontend frameworks are you most experienced with?",
      "context": "Kris has deep, long-running frontend experience across the major SPA ecosystems, with expert-level production work in React (since 2015), Vue (since 2016), and Angular (since 2011—strongest in the earlier generations, with less day-to-day time in the most modern Angular patterns). He’s been building large JavaScript applications since 1999 and has used TypeScript heavily since 2013, so he’s comfortable both shipping quickly and keeping codebases maintainable as they scale. He’s built customer-facing and admin UIs, real-time applications using WebSockets, and multiple Progressive Web Apps (PWAs) where offline/latency and performance characteristics actually matter.)\n\nHe’s also unusually strong in the “front-end systems” side that keeps teams productive: build chains, bundlers, and migration work. Over the years he’s worked extensively with Vite, Webpack, Rollup, esbuild, Gulp, and Grunt, and he’s comfortable diagnosing the hard problems—slow builds, broken dependency graphs, legacy bundling constraints, and incremental upgrades without breaking production. More recently, he’s leaned into SSR and hybrid rendering to address SEO and perceived performance for SPA-heavy products, using frameworks like Next.js and Nuxt (and experimenting with Vite SSR tooling such as vite-ssr/vitess) to get the best of both worlds: modern component-driven development with stronger initial render and indexability.\n\nOutside of production stacks, Kris keeps current by experimenting with newer frameworks in personal projects—most notably Svelte and SolidJS—which helps him evaluate tradeoffs and bring back proven ideas without chasing fads."
    },
    {
      "name": "What is your philosophy on whether something should be done on the frontend vs backend?",
      "context": "In 2000 at Storefront we pioneered what could be done in JavaScript on the frontend by designing very complex programs and playing tricks with the XML request object in IE (the good old days of var xhr = new ActiveXObject('Microsoft.XMLHTTP');.  Ever since then I have had a strong philosophy of pushing as much as possible to the frontend to improve responsiveness and user experience, while keeping security-sensitive and data-intensive operations on the backend.  With modern frameworks and build tools, it's possible to create rich, interactive applications that run efficiently in the browser, reducing server load and latency. However, since I started off as abackend developer, I always consider try to be pragmatic and do what is best for the end-user and factor in issues like SEO, accessibility, and maintainability when deciding where to implement functionality."
    },
    {
      "name": "What build tools have you worked with?",
      "context": "Kris has extensive hands-on experience with frontend build pipelines across multiple generations of the JavaScript ecosystem. He’s worked deeply with Vite for modern dev-server + bundling workflows, and has long-running production experience with Webpack (custom configs, loaders/plugins, multi-app builds, code-splitting, and performance tuning). He’s also used Rollup heavily—especially for libraries and more controlled bundling outputs—and has incorporated esbuild both directly and as a performance accelerator inside other toolchains. Earlier in his career he built and maintained sizable pipelines using Gulp and Grunt, including task automation for legacy apps and gradual migrations to newer tooling. Across React/Vue/Angular projects, he’s comfortable not only “using” these tools but owning the hard parts: diagnosing slow builds, upgrading dependencies safely, managing environment/config differences, and modernizing build systems incrementally without breaking production."
    },
    {
      "name": "Which back-end languages have you used most?",
      "context": "Kris’s core back-end experience is anchored in PHP, C#, JavaScript/TypeScript (Node.js runtime), and Python, chosen pragmatically based on the product stability and deployment constraints. He’s been building server-side systems in PHP since 1998 (including long-running commerce and partner-integrated systems), and has used C# since 2002, later leaning on ASP.NET Core / .NET Core for modern cross-platform backend services—starting around .NET Core 1.1 since 2016. He has also built substantial backend services in the Node.js ecosystem since 2012 (writing JavaScript/TypeScript, using frameworks like Express but has experience with many frameworks like Koa/Hapi/Hono/Meteor,Sails/Restify), and has used Python since ~2022 for automation, AI/ML-adjacent pipelines, and service development where it fit best. Earlier in his career, he also shipped production backend code in Perl and Ruby, which reinforces his strength as a polyglot who can move between ecosystems without losing engineering rigor."
    },
    {
      "name": "REST, GraphQL, or both?",
      "context": "Kris has used both, but he’s used REST far more frequently than GraphQL. When an external platform is clearly GraphQL-first—like the Shopify API (and, in his case, the Facebook API)—he’ll use GraphQL because it tends to provide better granularity, better-supported capabilities, and a cleaner developer experience than the parallel REST surface. In ecosystems that offer both, Kris has generally found the GraphQL implementation to be the more complete and thoughtfully designed option.\n\nWhen building his own APIs, though, Kris is cautious about adding GraphQL because it introduces real complexity and operational tradeoffs. He’s seen this firsthand: early on, an intern built a GraphQL layer for a small slice of Storefront functionality, but because it largely acted as a proxy over existing REST endpoints, it brought performance penalties and made caching harder. Since it didn’t deliver enough unique value relative to the added operational and implementation cost, the team ultimately removed it. That experience reinforced a practical rule: GraphQL is worth it when it unlocks material product or integration wins, but it’s not a default choice.\n\nExamples of “very good reasons” Kris would choose GraphQL when designing an API:\n\nClient-driven data shapes: multiple UIs (web/mobile/kiosk/partner embeds) need different subsets of the same entities, and GraphQL reduces endpoint sprawl and over-fetching.\n\nChattiness and latency pain: a screen currently requires many sequential REST calls; GraphQL can collapse that into a single request when the graph is modeled well.\n\nA strong typed contract is a force multiplier: teams benefit from a schema-first approach, introspection, and type-safe client generation—especially as the surface area grows.\n\nAggregation across services: you need a composition layer that pulls data from multiple backends/services so the client doesn’t have to orchestrate it.\n\nPlatform alignment: the primary platform API you’re integrating with is GraphQL-first (e.g., Shopify), so GraphQL is the most direct and feature-complete route.\n\nIn practice, Kris evaluates GraphQL with an operator’s mindset: can we cache it effectively, can we keep it fast, can we secure it cleanly, and is the added work justified for a small team? If the answer is “no,” REST remains the simpler, more robust default."
    } ,
    {
      "name": "Messaging/event-driven experience (Solace/Kafka/RabbitMQ)?",
      "context": "Kris is comfortable with event-driven architecture and messaging patterns, with production experience and pragmatic familiarity across multiple brokers. At Storefront, the only message bus used in production was Solace, where he worked with it extensively as part of core platform integration—using messaging to decouple systems, move work asynchronously, and connect legacy and newer components without forcing tight coupling. In addition to that production Solace experience, he’s also explored other brokers in practical contexts: the team ran internal evaluations with Kafka, and RabbitMQ was trialed in the kiosk project (ultimately not becoming the long-term production standard there). Outside Storefront, Kris has used RabbitMQ and BullMQ (Redis-backed queues) in consulting and personal projects, so he’s familiar with the “hands-on” mechanics as well as the architectural tradeoffs—durability vs throughput, ordering, retries/backoff, dead-lettering, idempotency, poison messages, and operational concerns like monitoring and backpressure. Overall, he approaches messaging as a tool for reliability and scale: using events when they reduce coupling and improve resilience, and being explicit about the operational disciplines required to make EDA trustworthy in production."
    } ,
    {
      "name": "How do you debug production issues?",
      "context": "Kris’s debugging approach is practical and iterative: start with the most direct evidence, get a repro if at all possible, stop the bleeding quickly, then harden the fix so it doesn’t come back. His first move is almost always logs—the lowest-level, most concrete record of what actually happened—paired with whatever context is available from user reports, support tickets, or monitoring alerts. Over time he’s found it critical to maintain a “known failure modes” knowledge base (his own notes plus a shared team wiki) because production issues repeat: the fastest path to resolution is often recognizing a familiar pattern.\n\nTooling-wise, he’s used Sentry, New Relic, Splunk, Kibana/OpenSearch (ELK-style logging), and OpenTelemetry. He values tracing, but he’s also pragmatic about it: OpenTelemetry can produce a flood of data, and his bias is to first identify the simplest concrete symptom (the specific error, request, or workflow that’s failing) before zooming out into distributed traces. For kiosk and device-fleet issues, remote management and telemetry were essential: pulling kiosk logs directly, correlating them with backend logs, and working with QA to reproduce issues reliably when they couldn’t be reproduced locally.\n\nReproduction is a key step in his process. After initial triage, he tries to reproduce the failure personally or through QA and then forms hypotheses grounded in real-world “classic” causes he’s seen repeatedly—time zone and locale bugs across countries, race conditions, caching inconsistencies, concurrency issues, integration drift, and edge-case data. When a fast repro isn’t possible, he focuses on narrowing the scope with additional logging, targeted probes, and carefully chosen test scenarios until the system’s behavior becomes predictable.\n\nWhen it comes to fixing, Kris separates mitigation from resolution. The first goal is to stop the impact without necessarily shipping code: a safe “duct tape” mitigation (cache clear, configuration toggle, a small operational change, a corrective database update, a temporary workflow change) can restore service quickly. Then he moves to a durable code fix that survives the next deploy and prevents recurrence. His “it’s fixed” bar usually includes: the underlying cause addressed in code when appropriate, tests added when feasible, and operational guardrails (alerts, runbooks, or automated checks). If something can’t be reliably tested in code, he prefers an automated verification (e.g., uptime checks) and, if needed, a documented manual checklist until automation is possible.\n\nFinally, Kris treats communication as part of debugging. He aims to share what happened and what was learned—via quick write-ups, incident notes, or lightweight postmortems—so the whole team benefits and recurring issues get faster to diagnose next time."
    } ,  
    {
      "name": "What about API design?",
      "context": "Kris approaches API design as a product and an operations surface, not just a set of endpoints. His default is **REST** with clear resource boundaries and predictable semantics, adding **GraphQL** only when there’s a strong reason (and often because an external platform like Shopify is GraphQL-first). He designs APIs to be easy for clients to use and hard to misuse: consistent naming, stable contracts, and behavior that remains understandable as the system grows across web, mobile, kiosk, and partner integrations.\n\nPractically, that means he pays close attention to the boring-but-critical details that determine whether an API survives in production:\n\n* **Contracts and versioning:** He prefers additive, backward-compatible evolution (new fields/endpoints rather than breaking changes), with explicit versioning when necessary.\n* **Security by design:** APIs are designed with secure defaults—least-privilege access, clear trust boundaries, strong input validation, and consistent handling of sensitive data (PII/payment-related metadata). He’s mindful of common threats (injection, replay, overbroad access, abuse/automation) and builds in protections like scoped tokens, rate limiting, and auditability where appropriate.\n* **Idempotency and reliability:** For any operation that might be retried (network glitches, kiosk connectivity, mobile clients), he designs idempotent workflows and stable request identifiers so retries don’t create duplicate orders, double charges, or inconsistent states.\n* **Performance and caching:** He designs for low-latency client experiences (especially kiosk/mobile), using pagination, filtering, and cache-friendly responses where appropriate—while staying aware of where caching is hard (e.g., highly personalized data).\n* **Operational visibility:** He builds APIs that are debuggable: structured logging, correlation IDs, traceability across services, and clear error responses that help support and engineering isolate issues quickly.\n* **Integration-first mindset:** Because much of Storefront’s success depended on partners, he’s experienced designing APIs and integration surfaces that work with external ecosystems—payments, fulfillment/lab systems, retail workflows, and commerce platforms—where you need to be resilient to upstream changes and partial failures.\n\nWhen the architecture calls for it, Kris also uses **messaging/event-driven patterns** alongside APIs—treating synchronous APIs as the “front door” for real-time needs and events/queues as the backbone for durable, decoupled processing. The result is an API design style that’s pragmatic, evolvable, and grounded in what keeps multi-channel, partner-integrated systems stable over years.\n"
    },
    {
      "name": "Which ML frameworks have you used?",
      "context": "Kris has hands-on experience with PyTorch, OpenCV, Scikit-learn, and Hugging Face Transformers, with a strong bias toward ML that actually ships and improves user workflows. He’s been using computer vision (primarily OpenCV) in production photo systems for 10+ years across multiple platform generations: Windows kiosks, a later Linux/.NET Core imaging service, and Android kiosk services (Java calling into OpenCV C components). That work included practical, customer-visible capabilities like photo enhancement pipelines (including color correction), red-eye reduction, face detection to enable smarter auto-cropping for templated products (e.g., photobooks), and “similar image” grouping to reduce gallery clutter (using a mix of perceptual hashing, color histograms, and capture date/time signals).\n\nOn the modern ML/LLM side, Kris has used PyTorch + Hugging Face Transformers for experimentation and prototyping, including LoRA-style adaptation and instruction-tuning-style experiments, and has built embedding/RAG workflows using transformer-based encoders (e.g., SentenceTransformers as a wrapper over Transformers/PyTorch). He’s also used Scikit-learn extensively for classical ML pipelines—feature extraction, training, evaluation, and clustering—especially when the problem is best solved with lightweight, explainable models rather than heavyweight generative approaches. Importantly, he evaluates ML choices pragmatically: if fine-tuning data, latency, or operational complexity don’t justify it, he’ll prefer strong low-cost foundation models or classical approaches that are easier to run and maintain.\n\nRelated posts on his blog: https://agingcoder.com/posts/experiments-in-supervised-learning/ ; https://agingcoder.com/posts/experiments-in-supervised-learning-part-2/ ; https://agingcoder.com/posts/can-a-tiny-llm-beat-a-supervised-model/ ; https://agingcoder.com/posts/clustering-the-cookbook-a-taste-of-unsupervised-learning/ ; https://agingcoder.com/posts/rag-time-cooking-up-smart-recipe-suggestions/"
    } ,
    {
  "name": "What AI-assisted coding tools do you use?",
  "context": "Kris has been using AI-assisted coding tools since 2021 and treats them as leverage for faster iteration without lowering engineering standards. His day-to-day toolkit includes GitHub Copilot for steady inline acceleration, and newer IDE/agent workflows such as Cursor and Windsurf-style environments for deeper refactors, codebase exploration, and multi-step tasks. He also uses command-line and agent-oriented tools—including Claude Code, OpenCode, Codex CLI, AntiGravity, and KiloCode—depending on the job: quick one-off transformations, repo-wide changes, test generation, documentation drafts, and implementation scaffolding.\n\nHe champions adopting these tools in a way that improves delivery and code quality rather than creating noise: keeping changes small and reviewable, insisting on tests/linters, validating edge cases, and treating generated output as a first draft that still needs experienced review. The result is higher throughput on routine work (boilerplate, refactors, migrations, glue code) while preserving maintainability, correctness, and operational reliability."
    }, 
    {
      "name": "How do you feel about AI, and its impact on software development?",
      "context": "AI is going to create a lot more software, but it still needs an experienced hand at the tiller. Kris is enthusiastic about the leverage—especially for proof-of-concept demos, interactive prototypes, documentation, and test scaffolding—but he’s wary of “YOLO vibe-coding into production.” He’ll absolutely let AI help with sensitive areas too, but only when the design is thought through upfront and the output is treated like untrusted code that must be audited: small diffs, careful review, and a real quality bar.\n\nHis biggest reservations are that today’s tools still struggle with truly complex systems, and that the combination of security footguns + human overconfidence is dangerous—especially as people start shipping code they don’t fully understand. That ties directly into his concern about skill atrophy: used well, AI could accelerate learning, but used lazily it can produce cargo-cult programmers who can assemble systems without grasping the failure modes.\n\nBecause of that, Kris’s workflow is deliberately conservative even when AI writes a large percentage of the code. His guardrails are non-negotiable: linting, unit tests plus e2e coverage, keeping changes small and reviewable, and real code review (including reviewing tests more closely than most people review feature code). He prefers refactors that are backed by static analysis where possible, and for scaffolding he often prefers modern CLIs because they tend to pull in current libraries and current patterns rather than stale defaults.\n\nHe’s also actively evaluating the shift from IDE-based assistants to CLI agents. He’s not fully decided yet, but the CLI approach is starting to win him over—especially for repository-wide work and workflow automation—while still insisting on reviewing every diff and keeping engineering discipline around the results.\n\nHis outlook is that the industry will see more output and more bugs in the near term: faster shipping cuts both ways. He expects an inflection point—either models become good enough that the “experienced hand” requirement shrinks substantially, or a high-profile failure (security, compliance, or systemic reliability) forces teams to slow down and formalize stronger safeguards."
    },
    {
      "name": "What native mobile experience do you have?",
      "context": "Kris has substantial native mobile experience on both major platforms, plus the “systems-level” Android work that most mobile developers never touch. On **Android**, he’s shipped production apps in **Java and Kotlin**, and he’s comfortable in modern Android UI with **Jetpack Compose** as well as the older View-based world. On **iOS**, he’s built native work in **Swift** and is comfortable with **SwiftUI** for modern declarative UI. He’s also delivered cross-platform apps where it made sense (e.g., **Flutter, Cordova, React Native**), but his native background means he can drop down to platform APIs when performance, device capabilities, or reliability demand it.\n\nBeyond typical consumer apps, Kris’s native experience includes deep involvement in the **Android Kiosk** platform, which required digging into Android at the OS/device level: operating in locked-down retail environments, integrating tightly with device hardware, and supporting kiosk-specific behavior through native services. Storefront created a **custom ROM**, multiple **native background services**, and even a **ROM updater** to manage fleet updates; Kris oversaw that work architecturally and from a delivery standpoint (even when he wasn’t the person writing every component), ensuring it was operable and maintainable at scale.\n\nOn the product side, he led delivery of consumer-facing mobile experiences including a TelCel-focused **Android** app for Mexico (Android-first market) that handled **photo upload, cropping, and payment via TelCel’s SOAP API** against user credits, and earlier white-label iOS/Android app work that covered the core photo-commerce flow (upload, edit, order, pay, fulfill) before the company shifted that experience to a mobile-first web/PWA approach.\n"
    },
    {
      "name": "Which cross-platform tools have you used?",
      "context": "Kris has used several cross-platform mobile stacks in real projects and consulting work, and he treats them as pragmatic tools—not ideology. His primary cross-platform experience includes **Cordova** (for web-to-mobile packaging and rapid delivery when the UI is largely web-based), **Flutter** (for higher-performance, more native-feeling cross-platform apps), and **React Native** (where it fits team skill sets and ecosystem needs). He’s comfortable with the typical cross-platform tradeoffs—plugin availability, platform quirks, performance hot spots, app size, build/release complexity—and because he also has strong native Android (Java/Kotlin/Jetpack Compose) and some iOS (Swift/SwiftUI) experience, he can drop down to native modules when a cross-platform layer hits a wall."
    },
    {
      "name": "Android or iOS preference?",
      "context": "Kris is comfortable building for both Android and iOS, but he’s personally more of an Android-first person day to day—and that has naturally influenced where he’s spent more hands-on time and what he reaches for first when prototyping or dogfooding mobile work. He did use an iPhone in the early days (3G → iPhone 4 era https://agingcoder.com/posts/switching-to-android-6-months-later ), then switched and has written about that transition and what he likes about Android as a platform.\n\nFrom a development standpoint, his “preference” is mostly practical: he biases toward Android when the work involves deeper device integration or systems-level constraints (kiosk/managed device fleets, background services, custom device behavior), where he has significant experience. For consumer apps, he’ll prioritize the market and user base over personal preference (e.g., Android-first delivery when the target market is overwhelmingly Android).\n\nTooling-wise, he’s historically had a dislike for Xcode  https://agingcoder.com/posts/coding-like-its-1999/ —he’s described it as feeling like stepping back in time—and while he’ll grudgingly admit it’s improved, it can still remind him of the bad old Eclipse days."
    },
    {
      "name": "Which databases are you most familiar with?",
      "context": "Kris has extensive database experience with both SQL (MySQL, PostgreSQL, SQLite) and NoSQL (MongoDB, Redis, CouchDB) technologies. He's designed and implemented database systems for enterprise platforms handling high transaction volumes."
    },
    {
      "name": "Experience with Redis caching?",
      "context": "Yes, Kris has experience with Redis as part of his database and caching expertise. He's used Redis alongside MySQL, PostgreSQL, MongoDB, and CouchDB in building scalable enterprise systems."
    },
    {
      "name": "What development methodologies do you prefer?",
      "context": "Kris has a strong foundation in Agile/Lean methodologies. He's directed agile teams of 10-15 developers through multiple full-cycle deliveries, integrating product, QA, and operations teams to accelerate time-to-market."
    },
    {
      "name": "Experience with TDD?",
      "context": "Yes, Kris has experience with Test-Driven Development (TDD) as part of his development practices. He emphasizes code quality through TDD, code review leadership, and modern development methodologies."
    },
    {
      "name": "How do you approach code reviews?",
      "context": "Kris has code review leadership experience as part of his development practices. As Director and Team Lead, he's established review processes and mentored developers through structured career development paths."
    },
    {
      "name": "What CI/CD experience do you have?",
      "context": "Kris has comprehensive DevOps experience with CI/CD pipelines using GitHub Actions, GitLab CI, and Jenkins. He's built containerized build pipelines using Docker, Kubernetes, Helm Charts, Kustomize, and Kaniko."
    },
    {
      "name": "Experience with Kubernetes?",
      "context": "Yes, Kris has experience with Kubernetes along with related tools like Helm Charts and Kustomize. He's built containerized build pipelines and has experience with event-driven architecture."
    },
    {
      "name": "Which CI/CD tools have you used?",
      "context": "Kris has used GitHub Actions, GitLab CI, and Jenkins for CI/CD pipelines. He's built containerized build pipelines using Docker, Kaniko, and orchestrated with Kubernetes."
    },
    {
      "name": "Any Helm or Kustomize experience?",
      "context": "Yes, Kris has experience with both Helm Charts and Kustomize for Kubernetes deployments. These are part of his DevOps toolkit along with Docker, GitHub Actions, GitLab CI, and Jenkins."
    },
    {
      "name": "How many programming languages have you worked with?",
      "context": "Kris is a polyglot developer who has released production code in 10+ languages and has experience with 20+ programming languages across different paradigms."
    },
    {
      "name": "Which are your strongest languages?",
      "context": "Kris's strongest languages include TypeScript/JavaScript (frontend and Node.js backend), PHP, C#, Python, Kotlin, and Swift. He's released production code in 10+ languages and experimented with 20+ languages."
    },
    {
      "name": "What is the Storefront E-Commerce Platform?",
      "context": "The Storefront E-Commerce Platform is an enterprise e-commerce system that Kris architected and developed starting in 2000. It powers photo product ordering for 10+ major retailers including Rite Aid, Costco Mexico, Fred Meyer, Smiths, Duane Reade, King Soopers, London Drugs, Benavides, and Dodd's Photo. It's still operational after 25 years."
    },
    {
      "name": "What was your role in it?",
      "context": "Kris was the architect and lead developer of the Storefront E-Commerce Platform. He designed and built the system from the ground up in 2000, and continued enhancing it with dozens of new features over the years to streamline retailer workflows and improve customer experience."
    },
    {
      "name": "How has it evolved over 25 years?",
      "context": "The Storefront E-Commerce Platform has been continuously enhanced over 25 years, adding dozens of new features, streamlining retailer workflows, increasing adoption rates, and improving the end-customer experience. It's been integrated with modern mobile platforms and retailer-specific plugins for photo products."
    },
    {
      "name": "Which retailers use it?",
      "context": "The Storefront E-Commerce Platform serves 10+ major retailers including Rite Aid, Costco Mexico, Fred Meyer, Smiths, Duane Reade, King Soopers, London Drugs, Benavides, and Dodd's Photo."
    },
    {
      "name": "Tell me about the kiosk system and its impact",
      "context": "The Storefront Windows Photo Kiosk was launched in 2005 with Kris as lead architect. It processed millions of prints annually and drove over $1B in photo product sales by 2010. The system served major retailers across multiple countries."
    },
    {
      "name": "What problem did this system solve?",
      "context": "The Kiosk File Transfer and Payment System solved the problem of transferring photos from mobile devices to kiosks and enabling secure phone-based payments. It eliminated kiosk credit card hardware costs and security risks, and was adopted by thousands of legacy Windows and modern Android kiosks."
    },
    {
      "name": "How does the file transfer work?",
      "context": "The Kiosk File Transfer system was designed in Node.js and React to enable seamless photo transfer from mobile devices to kiosks. It works across both legacy Windows kiosks and modern Android kiosks across multiple major retailers."
    },
    {
      "name": "What about the payment system?",
      "context": "The phone-based payment system eliminates kiosk credit card hardware costs and security risks. Customers can pay via their phones instead of swiping cards at the kiosk, improving security and reducing hardware maintenance costs."
    },
    {
      "name": "What does the Remote Management Platform do?",
      "context": "The Storefront Remote Management Platform provides centralized monitoring, remote access, scheduling, and automated error reporting for kiosks, lab software, and printers. It gives operations teams visibility and control over the entire device fleet."
    },
    {
      "name": "How does it handle 30,000+ devices?",
      "context": "The Remote Management Platform was architected to scale to over 30,000 devices with backend throughput of 12,000 requests per minute. It handles centralized monitoring, remote access, scheduling, and automated error reporting at this scale."
    },
    {
      "name": "What monitoring capabilities does it have?",
      "context": "The Remote Management Platform provides centralized monitoring, remote access, scheduling, and automated error reporting for kiosks, lab software, and printers across the device fleet."
    },
    {
      "name": "How did the distributed SaaS platform help partners?",
      "context": "The distributed SaaS platform enables rapid partner integration and scalability for customizable products and e-commerce integrations. Partners can integrate their websites to offer photo products like photo books, calendars, and template-based prints."
    },
    {
      "name": "What microservices architecture was used?",
      "context": "The distributed SaaS platform uses a microservices-based architecture with APIs for customizable products and e-commerce integrations. It was co-architected by Kris to enable scalability and rapid partner onboarding."
    },
    {
      "name": "What did Kris study at Langara College?",
      "context": "Kris completed the Advanced Computer Studies and Technology Program (ACST) at Langara College in Vancouver, BC from 1995-1998. This technical program prepared him for his software development career."
    },
    {
      "name": "What was the ACST program like?",
      "context": "The Advanced Computer Studies and Technology (ACST) Program at Langara College was a comprehensive technical program covering computer science and software development fundamentals. Kris completed it from 1995-1998."
    },
    {
      "name": "How did this prepare you for your career?",
      "context": "The ACST program at Langara provided strong technical foundations in computer science and software development. Combined with practical experience at TRIUMF and Canfor during the same period, it launched Kris's 25+ year software development career."
    },
    {
      "name": "What did Kris study at University of Western Ontario?",
      "context": "Kris graduated with an Honours BA in English Literature from the University of Western Ontario in 1993. This background has contributed to his strong communication and documentation skills throughout his technical career."
    },
    {
      "name": "How does English Literature help in tech?",
      "context": "Kris's English Literature degree contributes to his strong written communication, documentation skills, and ability to explain complex technical concepts clearly. He authored technical manuals at Langara College and continues to value clear communication in his leadership roles."
    }
  ]
}
